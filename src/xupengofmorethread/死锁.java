package xupengofmorethread;

public class 死锁 {
    /**
     * 在并发编程当中锁是一个很关键的实体，它可以很形象的
     * 控制，当前应该由哪一个线程来执行任务，并且其他线程
     * 要想获得这个锁必须等待。很好的控制各个线程之间的协作。
     * 但是如果锁使用不当很可能会发生死锁，发生死锁后某个线程
     * 会由于迟迟获取不料下一步任务的执行权利，将会进入死等待
     * 整个程序就会处于瘫痪状态。
     *
     * 避免死锁的几个技巧：
     *     1.尽量让一个线程同一时刻只获得一个对象的锁，那么它
     *       死锁后印象的任务范围将会小一点。
     *     2.尽量一个锁控制一份资源（一个共享变量），这样其他线程
     *       只要与这份资源没有关系，它就不会产生影响；同时只要
     *       当前线程获得锁开始执行，它就不会在中途需要获得其他资源的
     *       执行权利而等待。
     *     3.尝试使用定时锁，如果某个线程长时间请求一个对象的锁
     *       失败，那么它将放弃获得这个对象的锁，避免出现死等待
     *     4.对于数据库锁，加锁和解锁尽量在同一个数据库中操作
     *       不然会出现解锁失败的情况，引发死锁
     */
}

package xupengofmorethread;
public class 等待通知机制 {
    /**
     * 等待/通知机制，是指一个线程 A 调用了对象O的 wait() 方法进入等待状态，而另一个线程B
     * 调用了对象O的 notify()或者 notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而
     * 执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的
     * 关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。
     *
     * 使用这几个方法时需要注意的一些细节：
     *   1）调用这三个方法的前提条件是获得了当前对象的锁，因为没有获得
     *      对象锁，就谈不上释放对象锁然后进入waiting状态，也不会知道
     *      什么时候对象锁是空闲的，可以调用 notifyAll 方法通知其他线程
     *   2）调用 wait 方法后，当前线程会释放当前获得的对象锁，并且进入
     *       等待队列；需要明确的是这里的线程将失去获得该对象锁的权利。
     *   3）notify()方法是将等待队列中的一个线程移动到同步队列，而 notifyAll()方法
     *      是将当前等待该对象锁的所有线程都移动到同步队列中。waiting状态变为BLOCKED
     *      状态
     *   4）当然移动到同步队列中的线程只是有了获得对象锁的权利，但是具体能否获得
     *      锁，要等持有对象锁的线程释放锁。
     *   5）从wait()方法返回的前提是获得了调用对象的锁。
     *
     *
     *
     *  等待/通知的经典范式，该范式分为两部分，分别针对等待方（消费者）和通知方（生产者）。
     *  等待方遵循如下原则。
     *    1）获取对象的锁。
     *    2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。
     *    3）条件满足则执行对应的逻辑。
     *  对应的伪代码如下。
     *     synchronized(对象) {
     *        while(条件不满足) {
     *           对象.wait();
     *        }
     * 对应的处理逻辑
     * }
     *     通知方遵循如下原则。
     *      1）获得对象的锁。
     *      2）改变条件。
     *      3）通知所有等待在对象上的线程。
     * 对应的伪代码如下。
     *     synchronized(对象) {
     *         改变条件
     *        对象.notifyAll();
     *      }
     */
}

package xupengofmorethread;
/**
 *     文章主题：多线程基础知识回顾
 *     目录索引：1.线程和进程的关系，为什么要引入线程
 *               2.多线程的问题
 *               3.线程安全性，可见性，原子性，有序性
 *               4.线程同步和异步，并发和并行
 */
public class AboutThread {
    /**
     * 1.线程和进程的关系，为什么要引入线程
     *    进程是系统分配资源的基本单位，每个进程在创建时都会拥有自己的
     *    内存空间，主要包括文本区域（执行代码），数据区域（变量和进程
     *    执行期间使用的动态分配的内存）和堆栈（进程调用的指令和本地变量）。
     *   早期的计算机，刚引入操作系统时，采用的是多进程模型；这样相比于
     *   单进程来说有更好的优势，不会因为单个进程的阻塞使得其他任务无法执行
     *   而cpu却一直处在空等待的状态。有了多进程之后，当一个进程由于磁盘读写
     *   数据时被阻塞，其他进程可以获得cpu的执行权，继续让CPU忙碌；这样大大的提升
     *   了资源利用率。但是某个进程执行的任务往往分为多个模块，比如某时刻需要
     *   从磁盘读写数据，并且将结果显示到界面上。当一个进程执行从磁盘中读取数据一
     *   半时阻塞了，此时CPU处于空闲状态，最好的方案是把cpu 的执行权转换
     *   给另一进程执行，但是这样是存在问题的：进程间切换需要不断的从
     *   用户态和内核态copy数据，这样非常消耗系统资源，并且更要命的是之前被IO阻塞
     *   的进程在读取完数据时，还不知道猴年马月才能再次获得CPU的执行权，假如该进程
     *   的作用是为用户显示最新的消息，并在界面上显示，那么此时用户将会得到相当差
     *   的体验效果，延迟高到爆，用户根本不会明白你的苦衷（磁盘读取数据和联网等操作到底有多慢），只会觉得你的执行效率太
     *   低了，此时，不耐烦的用户将会分分钟将你在资源管理器中kill，免得影响访他问
     *   其他软件的速度。那么此时被kill的进程就需要思考，为什么不能一边读取数据
     *   一边显示呢，这样让用户知道自己在不断的努力读取并显示数据，而不是“什么都没有干”
     *   答案是肯定的：只要该进程在内部定义两个执行流程（线程），一个T1用来读写磁盘
     *   另一个T2用来显示界面，这样当T1在读写磁盘时阻塞了，可以让T2执行已经读取好的
     *   一部分数据显示到界面上，这样就不至于直接让出CPU的执行权给其他进程了。这样用户
     *   体验也会好一点，不至于直接kill,看后面的表现。上面提到的T1,T2就是线程，线程是进程中的不同执行流程，同样也是
     *   CPU调度的基本单位，一个进程引入多线程的优势有以下三点：
     *   1）发挥多核处理器的优势，如果一个进程是单个线程的，在双核心的处理器中就会
     *      浪费50%的CPU资源，3核心的处理器中就会浪费75%的cpu资源，以此类推，后果
     *      不堪设想，采用多线程刻不容缓。多线程可以通过提高系统资源利用率，来提高
     *      系统吞吐率，也就是在单位时间内做更多有意义的事，何乐而不为之。
     *   2）可以防止阻塞，设想这样一个场景，如果一个进程中只维持了一个线程，那么这个
     *      线程一旦因为某种原因阻塞了，就会像之前描述的那样，相当于一个进程阻塞了
     *      不但要让出CPU的执行权，而且会给用户带来极差的体验效果；有了多线程就不怕了
     *      当前执行线程阻塞了，可以让另一个线程获得CPU 的执行权，继续执行，这样就
     *      不至于让cpu长时间处于空闲状态，其他进程也就没有理由剥夺当前进程的CPU执行权了
     *   3）当需要多种类型的任务需要完成时，通过使用线程，可以将复杂并且异步的工作流
     *      进一步分解为一组简单并且同步的的工作流，每个工作流在一个单独的线程中运行
     *      并在特定的同步位置进行交互；这样就简化了整个任务执行的难度。
     *
     * 2. 优秀的多线程给我们带来的问题：
     *      几乎所有新鲜并且优秀技术的引入，都会附带很多技术难题和活跃性问题；
     *      1.最显著的线程安全性问题，在一个多线程程序中，如果没有实现充足的同步，
     *        由于线程之间切换执行都是瞬间的，并且线程之间的执行顺序是不确定的
     *        这样就给程序的执行结果带来了很多不可预测的结果，因为你没有办法控制
     *        当前那个线程会执行到程序的哪一行。
     *      2.活跃性问题，比如，死锁 饥饿 活锁 以及死循环问题
     *      3.性能问题，与活跃性问题相互对应，活跃性问题导致系统性能问题
     *        例如 超时响应 吞吐率过低 资源消耗过高 多线程之间频繁切换给系统
     *        会带来极大的开销。
     * 3.线程安全性，可见性，原子性，有序性
     *    3.1.线程安全性是指在多线程环境下程序执行的结果总是与单线程环境下
     *        执行的结果一样，我们就说该程序是线程安全的；也就是说，当多线程
     *        访问某个类时，总能按照我们预测的结果运行处结果，此时我们就说这个类
     *        是线程安全的。线程安全通常被分为三个级别：1.绝对线程安全 比如
     *        J.U.C下的 CopyOnWriteArrayList就是一个绝对线程安全的类，它不需要做任何的
     *        同步就是线程安全的；2.不可变，如果一个类是不可变的，那么它也是一个线程
     *        安全的类，比如常见的String类，被final修饰并且创建之后就不会被修改(需要
     *        补充一点的是String 类中的有些域是非final类型的，但是不影响它的不变性
     *        比如hash值这个属性是在调用hashcode时才会被初始化的，但是由于hash拥有一个
     *        非默认值确定后就不会改变，每次调用hashcode之后，hash值被实例化，并且
     *        每次调用都会拿到同一个hash值，这样就保证了整个String的不变性)。
     *    3.2.可见性是指多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程
     *        能够立即看到修改的值，此时我们就说该变量具有可见性。举个简单的例子：
     *        线程一执行：int i = 0； i = 10；
     *        线程二执行： j = i;(假设j已经被定义)
     *        假设线程一执行i = 10这一行时，首先将i的初始值0 copy一份到自己的高速缓存区
     *        然后将i的值改为10，但是没有将修改后的值刷新到主存中；此时线程二获得cpu的执
     *        行权，先从主存中copy一份i的值，此时拿到的是0，执行完j = i，就将j变为了0而
     *        不是我们希望的10，这就是典型的可见性问题，如果线程二执行时可以感知到线程一
     *        对i的最新修改，这样就不会出现这种问题了。
     *    3.3.原子性是指某一个操作或多个操作要么全部执行，要么全都不执行，此时我们称
     *        这样的操作为原子性操作。最典型的例子是在高并发秒杀系统中，执行秒杀操作就
     *        必须是一个原子操作，主要包括两个步骤，修改库存数量和添加购买明细；这两步
     *        要么全部执行，要么执行到一半出错了，就必须回滚到秒杀刚开始的状态。因为如果只
     *        改变了库存，而没有添加购买明细，商家在秒杀结束后对账时就会出现混乱；如果添加
     *        了购买明细，而没有减库存，那么会出现同样的情况。
     *    3.4.有序性是指处理器为了提高程序运行效率，可能会对程序中代码的执行顺序做一定的
     *        调整，但是会确保最终的执行结果和顺序执行的结果一样。
     *        例如： 1.int a = 10;  2.int r = 2; 3.a = a + 3; 4.r = a * a;
     *        由于第一句和第二句没有依赖关系，所以可能会发生指令重排序；但是
     *        第三句和第四句有依赖关系，所以不会发生指令重排序。
     *   4.线程的同步和异步，并发和并行
     *    4.1.同步是指多个线程协作完成一个任务，假如整个任务完成需要三个步骤，那么一个
     *       线程执行第一步，另一个线程需要执行第二步就必须等待第一个线程执行结束，并返回
     *       第一步的结果才可以进行第二步的工作。多个线程同步的好处是总会出现一个可靠的
     *       运行结果，而不是混乱不可预测的一种运行结果。异步是指多个任务虽然互相依赖，但是
     *       但是并不需要等待被依赖的任务完成，只需要和被依赖的任务协商好，相互之间需要
     *       传递那些数据，然后各自执行各自的任务，互不影响；也不会关注被依赖的任务最后
     *       到底是否真正执行成功了。所以异步执行策略是一个非可靠的执行策略。
     *    4.2.并发是指在同一时刻，只能有一条指令（一个进程）执行，但多个线程被快速切换执
     *        行，使得让它具有了多个线程同时执行的效果。并行是同一时刻多个处理器同时处理
     *        多个任务，比如双核处理器同时执行两条不同的指令，互不影响。当有多个线程在操
     *        作时，如果你的系统只有一个CPU，则它不能同时执行多个线程，只能是多个线程之间
     *        不断切换获得CPU资源，CPU时间片被划分为若干个小块，在某个时间小块内，当前CPU
     *        只能执行一个线程此时其他线程处于挂起状态。如果你的系统有一个以上的CPU 那么线
     *        程的操作就有可能是并行，一个线程在一个cpu上执行时，其他线程可以在另一个CPU上
     *        同时执行。
     */
}

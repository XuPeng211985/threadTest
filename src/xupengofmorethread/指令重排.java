package xupengofmorethread;
/**
 * 本地内存：
 *
 * 在jvm内存模型中，所有执行线程都会拥有自己的本地内存，包括缓存
 * 写缓冲区和寄存器以及处理器的性能优化指令等。在java中多个线程
 * 是通过共享内存的方式来实现通信的，当某个变量被多个线程共享时，
 * 每个线程的想要修改共享变量时就需要从主存中copy一份共享变量的
 * 值放在自己的本地内存中，然后在本地写缓冲区中对共享变量进行修改。
 * 最后再刷新到主存中；
 * 有本地内存的好处有两点：
 *   1.可以让指令流水线持续执行，而不用让处理器将大量的时间花费在
 *     等待向主存刷新数据这件事情上。提高程序的运行效率
 *   2.有了本地内存中的写缓冲区，就可以将多次写入进行合并，然后将结果
 *     统一刷新到主存中，这样就减少了主存被独占的时长，对其他线程进行
 *     写入提供了便利。
 *
 * 指令重排：
 *   有了上面的本地内存就会出现一个问题：假如现在有一个多线程的场景
 *     初始状态 a = b = 0
 *     线程一 执行 a = 1；x = b;
 *     线程二 执行 b = 2; y = a;
 *     在线程一和线程二并发执行时，就会出现这种情况，当线程一执行完a = 1
 *     这条指令后线程一所在的本地内存中将a的值修改为1，此时线程二开始执行
 *     当执行y = a时，线程二会从主存中查找a的值并赋值给x,而此时线程一的修改
 *     对于线程二是无感知的，所以线程二会得到一个假的数据a = 0 赋值给x
 *     同样的情况，x也有可能取到假的数据b；这种情况就是发生了指令重排序
 *     按照程序的执行顺序应该是先写入，然后刷新到主存，最后读取；而指令重排序
 *     后变成了先读取然后在率性到主存，这样就容易发生数据脏读的情况。
 *
 *     happens-before的理解：
 *
 *      三种情况列举一下： 程序顺序，上一句代码happens-before于下一句代码
 *                         数据加锁操作时，对象的解锁happens-before于下一个线程对该对象的加锁
 *                         对于volatile域来说，对变量的读取操作一定是在该变量写的后面
 *     需要明确的是，并不是具有happens-before语义的两段代码前者就一定在
 *     后者前面执行，比如在求圆的面积时一般需要三部：1 获得圆周率 2 获得圆的半径 3 套用公式计算
 *     按照程序顺序执行的happens-before语义 1 happens-before于 2 。但是由于处理器的优化方案
 *     1 和 2 并没有数据依赖关系，所以可以发生重排序，也就是说2 可以在 1 之前发生。
 *
 *     数据依赖的三种情况： 写写  写读  读写
 *
 *     另一个语义：as-if-serial
 *       只要具有数据依赖关系的指令都不能进行指令重排序
 *       也就是说指令重排的条件是在单线程环境下，改变两条
 *       指令的顺序，不会影响执行结果，那么这两条指令可以进行指令重排。
 *
 *       当两个操作存在控制依赖关系时，处理器允许先执行控制语句内的代码
 *       然后将结果存储在一个临时缓冲区中，直到判断成功就将结果再返回
 *       给执行体
 *         if(flag){ //操作1
 *             a = i * i;//操作2
 *         }
 *         实质上就是操作1和操作2而进行了重排序
 *
 *
 *
 *       在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，
 *     尽可能提高并行度
 *
 *     追求的目标一直是，顺序一致性性内存模型（理想化的）
 *     无论多少个线程进程同一个共享变量的执行权，他们都必须按照程序
 *     规定的顺序来依次执行。
 *
 */
public class 指令重排 {
    /**
     * 场景描述：假设现在有两个线程，线程1执行write方法
     *      线程2执行read方法，从程序的整个执行流程来看
     *      最终目的是想让变量i接受对a修改后的值
     *
     *     但是在实际执行过程中，编译器和处理器可能会对两个方法中
     *     的两条指令都进行重排序，因为无论是写方法还是读方法，他们包含
     *     的两条操作都不具有数据依赖性；经过重排序后write()方法中的第二条指令
     *     就会在第一条指令之前执行，这样flag呗提前修改，线程二感知到这个修改
     *     就会以为变量i已经被成功修改，结果用i接收到一个错误的结果i = 0 * 0;
     *     然后线程一接着执行对i的写入，但是此时这个数据已经无效了，因为i已经接受
     *     到数据了。
     *
     * 操作3和操作4存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序
     * 列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并
     * 行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把
     * 计算结果临时保存到一个名为重排序缓冲（Reorder Buffer，ROB）的硬件缓存中。当操作3的条
     * 件判断为真时，就把该计算结果写入变量i中。
     */
   private int a = 0;
   private boolean flag = false;
   private int i = 1;
   public void write(){
       a = 1;//操作1
       flag = true;//操作2
   }
   public void read(){
       if(flag){//操作3
           int i = a * a;//操作4
       }
   }
}

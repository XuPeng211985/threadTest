package xupengofmorethread;
public class 锁和volatile {
    /**
     * 我对锁的理解是在屏蔽其他线程的情况下独享一片公共的内存区
     *      synchronized通常获得对象锁，  锁锁住一段代码块，要么是一个方法
     *      要么是一个代码片段，在这个临界区中该线程将会获得该对象持有的所有
     *      共享变量的独占权，直到当前获得锁的线程执行完后之后才能释放锁
     *      接着其他线程就可以获得该对象的锁，进入临界区开始执行。
     *      volatile与锁的语义比较像，都是获得锁，但是volatile针对的是一个变量
     *      当一个变量被修饰为volatile类型后，每当一个线程对该变量进行写时
     *      就会在该变量的写指令上加一个lock前缀，表示当前变量所在的高速缓存
     *      或者主线内存被当前线程锁定，并且比锁更简洁的是，其他线程能快速感知
     *      到当前线程对共享变量的修改。
     *      它们两者之间的关系是锁的释放与写一个volatile类型的变量的内存语义相同
     *      释放锁表示修改变量完成，其他线程可以在主存中拿到新修改的值，而写入
     *      volatile变量也是表示当前变量被修改，其他线程感知到这个修改然后进行缓存无效设定
     *      接着从主存中查找最新的修改；锁的获得和读一个volatile类型的变量的内存语义相同
     *      获得锁的前提是其他线程退出了临界区，当前线程获得锁后会对新获取的数据进行运算
     *      而读取一个volatile类型的变量也是在其他线程对该变量进行修改之后进行的一些运算
     */
}

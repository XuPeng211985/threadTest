package xupengofmorethread;

public class 几种更优秀的锁 {
    /**
     * jdk1.6以后，对重量级锁进行了一些优化；对象锁被分为
     * 四个等级：无锁 偏向锁 轻量级锁 重量级锁 锁的等级可以
     * 升高但是不能降级。
     *
     * 偏向锁： 很多场景下的默认选项，因为大多数并发场景下为了避免死锁
     *      以及激烈的锁竞争，都会尽量让一个线程去操作一个共享变量，
     *      那么这个线程在访问该变量时就需要不断地获得或释放该对象的锁；
     *      那么在这种场景下，其实完全可以将该对象的锁和当前线程绑定，如果
     *      每次尝试获得锁的线程还是当前线程，那么就不用再次获得对象锁，而是
     *      直接进入同步代码执行；（设置偏向锁的方式是直接将当前绑定的线程ID
     *     放在对象的MarkWord中，这样每次线程要访问共享变量时只需要比较线程ID
     *     是否匹配即可）。
     *
     * 释放偏向锁：当然当其他线程想要访问该偏向锁绑定的对象时取决于已经绑定线程的选择
     *    此时会设置一个安全点，停止当前运行的任务，并判断被绑定的线程是否活着
     *   如果死了，那么把当前对象改为无锁状态，接着其他线程可以再次绑定该对象的锁
     *  但是如果当前线程没有死，那么会让他继续执行，并且执行完成后会做出
     *  选择，让出绑定权利 或是将该对象的锁级别升级。
     *
     *  轻量级锁：首先当前尝试获得轻量级锁的线程会将操作的对象头部信息
     *      copy一份到到自己的操作数栈中，并且会尝试使用CAS操作将对象头
     *      的MarkWord替换为锁记录的对象地址，如果替换成功那么当前线程获得锁
     *      如果替换失败，那么当前线程会自旋等待一段时间，而后获得锁的
     *      执行权利。
     *
     *  释放轻量级锁：首先当前线程会把运行栈中的锁信息运用CAS操作写入到对象头
     *      中，如果写入成功说明当前不存在锁竞争，反之将该锁升级为重量级锁。
     *
     *      几种锁的优缺点：1  偏向锁不存在获得锁和释放锁的开销 ，但是在高争用
     *                         锁的场景下，会增加额外的绑定撤销操作
     *                  适用于只有一个线程访问同步块
     *                       2  轻量级锁，在高争用场景下依然适用，并且用自旋等待
     *                        代替直接阻塞，减少了挂起和唤醒一个线程的开销；
     *                        同时存在的问题是锁自选需要占用CPU的执行时间，频繁
     *                        的自旋会极大的影响性能。
     *                   适用于追求响应时间而忽略系统CPU的消耗
     *                        3 重量级锁最大的优势就是绝对安全，不存在CPU的消耗，缺点也是显而易见
     *                          响应时间特别慢。
     *                      适用于同步代码块执行时间较长 的场景。
     *
     */
}

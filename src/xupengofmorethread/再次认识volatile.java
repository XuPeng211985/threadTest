package xupengofmorethread;

import java.util.concurrent.LinkedTransferQueue;

public class 再次认识volatile {
    /**
     * volatile是轻量级的synchronized,它在多处理器系统中为
     * 各线程提供了某些变量的可见性，也就是说当一个线程在
     * 修改一个被volatile修饰的变量后，其他线程会立刻感知到
     * 变量的具体变化，这样就减少了线程之间的上下文切换，不用
     * 频繁的获得变量的锁，就会感知到它的变化。除了在修改时需要获得
     * 该对象的锁以外，其他情况下都不需要对象锁。
     *
     * CPU术语：
     *   缓存（读）命中：如果下一次程序需要修改的内容所在的内存地址和当前缓存行中的地址一致
     *             那么就不需要从主存中提取数据，而是直接在高速缓存中读取数据
     *   写命中：同样的道理，如果一个线程想要修改一块内存的数据，它会先检查缓存
     *          行中是否存在没有失效的缓存行指向这块内存，如果有那么直接在缓存行
     *          写入，而不用改动主存中的数据，当然下次有其他线程修改时，这块缓存行
     *          肯定失效了，需要从主存中copy一份到缓存再进行修改。
     *
     *volatile实现可见性的方法：
     *    Java代码如下。
     *    instance = new Singleton(); // instance是volatile变量
     *    转变成汇编代码，如下。
     *    0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);
     *   如上面的例子所示，被volatile修饰的变量在进行修改时，jvm 会对该变量加一个锁前缀
     *   这个锁前缀除了在修改值时保证排他性的同时还会为该变量加一个已经修改了的标识
     *   这个标识会被其他线程看到，其他线程想要访问这个变量时就会感知到该变量的
     *   变化，肯定了缓存行无效后，会从主存中重新读取该变量新的值。
     *   换言之，被volatile修饰的变量只要已被修改，就会立马更新到主存，并且通知
     *   其他线程关于这个变量的缓存行失效。
     *
     *   ============需要注意的是在为volatile变量上锁的时候，一般情况下锁住
     *   的是当前线程所在的缓存而不是地址总线内存，这样做也是很好理解的：
     *   锁住总线意味着其他CPU都不能访问这块内存，将会降低系统吞吐率。如果锁
     *   住的只是当前线程的缓存行，那么受限制的范围会缩小一点。
     *
     *
     *   使用优化：LinkedTransferQueue
     *
     *
     */

}


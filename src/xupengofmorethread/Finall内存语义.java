package xupengofmorethread;

/**
 *     以前对final真是一无所知： 不可变  呵呵 想少了
 */
public class Finall内存语义 {
    /**
     * JMM禁止编译器把final域的写重排序到构造函数之外
     *     写final域的重排序规则可以确保：在对象引用为任意线程可见之前，
     *     对象的final域已经被正确初始化过了，而普通域不具有这个保障。
     *     假设现在一个类中有两个属性 一个是普通域，另一个是final域
     *     在构造函数中同时初始化这两个域；与此同时会有一个线程访问
     *     初始化后的这个对象，此时它就有可能访问到一个还没有初始化完成
     *     的对象，因为该对象的普通域在多线程环境下可能会在构造函数之外
     *     被初始化，这样就会造成数据脏读的现象。
     *     因此要想读取到正确被初始化后的对象，必须把该对象的域都设置为
     *     final类型。这样处理器在初始化对象时就会添加一个写屏蔽，防止
     *     其他线程在没有初始化完成之后访问该对象。
     *     另外在早期的X86处理器中由于处理器自身保证写写操作和隐式依赖
     *     语句不会发生重排序；所以处理器直接省略了在对final类型的对象
     *     进行初始化时的读写屏蔽；这样就会造成其他线程可以在构造函数
     *     执行的过程中访问该对象，并对该对象的某个域进行修改；这样就会
     *     破坏final关键字的不可变特性；所以在后期的处理器中明确加上了
     *     读写屏蔽，保证了final类型实体的不可变性。
     * 需要注意的是：
     *    1.在构造函数中不能将当前对象溢出，就是不能将正在初始化的对象
     *     指向外部引用；防止构造函数内部发生指令重排序，然后外界读取到没有初始化完成的对象。
     *    2. JMM可以确保读线程能看到写线程在构造函数中对final引用对象的成员域的写
     *      入。但是写线程对数组元素的写入，读线程有可能看得到，也可能看不到。JMM不
     *      保证写单个元素线程的写入对读线程可见，因为写线程和读线程之间存在数
     *      据竞争，此时的执行结果不可预知。
     *  举例 ：
     *  public class FinalReferenceExample {
     *    final int[] intArray; // final是引用类型
     *    static FinalReferenceExample obj;
     *    public FinalReferenceExample () { // 构造函数
     *        intArray = new int[1]; // 1
     *        intArray[0] = 1; // 2
     *    }
     *   public static void writerOne () { // 写线程A执行
     *   obj = new FinalReferenceExample (); // 3
     *   }
     *   public static void writerTwo () { // 写线程B执行
     *     obj.intArray[0] = 2; // 4
     *   }
     *    public static void reader () { // 读线程C执行
     *       if (obj != null) { // 5
     *           int temp1 = obj.intArray[0]; // 6
     *        }
     *    }
     * }
     * 线程C可以看到构造函数中线程A对下标为0的元素的写入，但不定能看到
     * 线程B对下标为0的元素的写入。
     *
     *
     * JMM总是遵循一个基本原则：
     *    只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），
     *    编译器和处理器怎么优化都行。例如，如果编译器经过细致的分析后，认定一个锁只会被单个
     *    线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变
     *    量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些
     *    优化既不会改变程序的执行结果，又能提高程序的执行效率。
     */
}
